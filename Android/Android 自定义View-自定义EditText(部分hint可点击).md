#[自定义 View ] 自定义 EditTex t:部分 hint 可点击自定义 EditText ，**增加**的主要功能是：部分 hint 可以点击（点击区域最多能有两行）； 可以选择是否添加平行线（每行的下划线）  ###效果图###自定义属性：attrs.xml  ```<!--部分 hint 可点击的自定义 EditText --><declare-styleable name="FunHintEditText">    <!--可点击部分的前景色-->    <attr name="fgHintClickableRegion" format="color"/>    <!--可点击部分的背景色-->    <attr name="bgHintClickableRegion" format="color"/>    <!--平行线（下划线）的颜色-->    <attr name="colorParallelLines" format="color"/>    <!--是否需要平行线-->    <attr name="drawParallelLines" format="boolean"/>    <!--可点击部分之前的文字-->    <attr name="hintFormer" format="string"/>    <!--可点击部分的文字-->    <attr name="hintValue" format="string"/>    <!--可点击部分之后的文字-->    <attr name="hintLatter" format="string"/></declare-styleable>```###思路实现部分 hint 可以点击的思路如下：1. 将 hint 分成三个部分：`hintFormer`、`hintValue`、`hintLatter`。其中 hintValue 是可以点击部分的文字，hintFormer 和 hintLatter 分别是其之前和之后的文字  ```/*可点击文字前的文字 */private String hintFormer;/*可点击的文字 */private String hintValue;/*可点击文字后的文字 */private String hintLatter;```  2. 计算 hintValue 的位置，定义了 8 个变量来记录 `x轴和y轴` 的起始位置:  ```//可点击 hint 的范围  int pStartX1, pStartY1, pEndX1, pEndY1,pStartX2=0, pStartY2=0, pEndX2=0, pEndY2=0;```  为什么定义 8 个变量呢？  因为可点击的部分有可能在行末，并且超出进入下一行，4 个变量只能确定一个可点击的范围。所以前 4 个变量用来记录第一个部分，后 4 个变量用于记录第二个。所以最大支持两行可点击的 hint 。   具体处理如下：···/**     * 事件处理     * 实现部分 hint 可点击     * @param event event     * @return true:自己消费，不向上级传递     */    @Override    public boolean onTouchEvent(MotionEvent event) {        //可点击 hint 的范围        int pStartX1, pStartY1, pEndX1, pEndY1,pStartX2=0, pStartY2=0, pEndX2=0, pEndY2=0;        //给 EditText 设置的文字大小        int textSize = (int) getTextSize();        //测量指定文字宽高        Rect rect = new Rect();        Paint paint = new Paint();        paint.setTextSize(textSize);        //获取 hintFormer 文字的大小        paint.getTextBounds(hintFormer, 0, hintFormer.length(), rect);        int widthHintFormer = rect.width();        int heightHintFormer = rect.height();        //hintFormer 占多少行        int lines = widthHintFormer / getMeasuredWidth() + 1;        //当前手指抬起的时候事件处理        if (event.getAction() == MotionEvent.ACTION_UP) {            //获取在当前View上点击的位置            int dx = (int) event.getX();            int dy = (int) event.getY();            //获取每行可以容纳多少个字            int charsPerLine = getWidth() / textSize;            //            LogUtil.showLog(getClass().getName(), "coordination: (" + dx + "," + dy + ")");            //从hintValue所在的一行开始截取字符串            String measureText = hintFormer;            if (lines != 1) {                measureText = hintFormer.substring((lines - 1) * charsPerLine - 1);            }            //计算截取后的字符串的宽度            paint.getTextBounds(measureText, 0, measureText.length(), rect);            // hintValue 的开始范围            pStartX1 = rect.width() + getPaddingStart() - 30;            pStartY1 = heightHintFormer * (lines - 1) - 10;            //计算 hintValue 的宽度            paint.getTextBounds(hintValue, 0, hintValue.length(), rect);            // hintValue 的结束范围            pEndX1 = pStartX1 + rect.width() + 30;            pEndY1 = heightHintFormer * lines + 10;            //如果 hintValue 的结束范围大于了控件宽度，则说明hintValue 跨行了，则需要另一个结束            if (pEndX1>getWidth()){                pEndX2=pEndX1-getWidth();                pStartY2=pStartY1+heightHintFormer;                pEndY2=pEndY1+heightHintFormer;            }//                LogUtil.showLog(getClass().getName(), pStartX + ":" + pEndX + ":" + pStartY + ":" + pEndY);            //在 hintValue 范围内的点击，自己处理            if ((dx >= pStartX1 && dx <= pEndX1 && dy >= pStartY1 && dy <= pEndY1)                    ||(dx >= pStartX2 && dx <= pEndX2 && dy >= pStartY2 && dy <= pEndY2)) {                //使 EditText 失去焦点，无法弹出键盘，处理自己的事件                setFocusable(false);                setFocusableInTouchMode(false);                if (listener != null) {                    listener.onHintClick(this);                }                return true;//自己消费事件，不传递给父级            }        }        //在指定范围之外的点击，则设置可获取焦点，并弹出键盘        setFocusable(true);        requestFocus();        setFocusableInTouchMode(true);        return super.onTouchEvent(event);    }···  代码注释较详细，逻辑也简单，就不重复叙述了。###使用方法 1. 在 **values** 文件夹下添加 `attrs.xml` 中自定义的属性：  ```<!--部分 hint 可点击的自定义 EditText--><declare-styleable name="FunHintEditText">    <!--可点击部分的前景色-->    <attr name="fgHintClickableRegion" format="color"/>    <!--可点击部分的背景色-->    <attr name="bgHintClickableRegion" format="color"/>    <!--平行线（下划线）的颜色-->    <attr name="colorParallelLines" format="color"/>    <!--是否需要平行线-->    <attr name="drawParallelLines" format="boolean"/>    <!--可点击部分之前的文字-->    <attr name="hintFormer" format="string"/>    <!--可点击部分的文字-->    <attr name="hintValue" format="string"/>    <!--可点击部分之后的文字-->    <attr name="hintLatter" format="string"/></declare-styleable>```2.在 **values** 文件夹下添加 `colors.xml` 中自定义的颜色（因为有一些默认的颜色）：```<!--自定义ViewValuableHintEditText--><color name="cos_blue">#003AFF</color><color name="cos_cyan">#B3DFFD</color><color name="cos_darkPink">#FF0066</color><color name="cos_shallowPink">#FFBCE7</color>```3.在 **layout** 布局文件中添加即可，例如：```<com.android.appdemo.FunHintEditText    android:id="@+id/fun_hint_edit_text"    android:layout_width="match_parent"    android:layout_height="200dp"    android:layout_marginStart="8dp"    android:layout_marginTop="8dp"    android:layout_marginEnd="8dp"    app:hintFormer="这是部hint可点击的EditText，你可以点击"    app:hintValue="这里"    app:hintLatter="来实现具体的需求"    app:layout_constraintEnd_toEndOf="parent"    app:layout_constraintStart_toStartOf="parent"    app:layout_constraintTop_toTopOf="parent" />```