﻿﻿﻿﻿﻿﻿﻿﻿﻿  # Java 自动拆箱与自动装箱从 Java SE 5 开始，Java 就提供了自动拆箱与自动装箱功能。什么是自动拆箱与自动装箱？为什么要有自动拆装箱功能？#### 基本数据类型与引用数据类型	- 引用数据类型	我们知道，Java 是面向对象语言，实例一个对象用 **new** 关键字，而 ***new*** 出来的对象会被储存在堆中，通过栈中的引用来使用这些对象；所有能 ***new*** 出来的对象都是引用数据类型	- 基本数据类型 	而经常被使用的不需要使用 **new** 的数据类型就是基本数据类型，这些类型的数据直接存储在内存栈中，所以相对于引用类型效率更高。#### 基本数据类型与及包装类Java 中的基本数据类型都有其对应的包装类| 基本数据类型 | 对应包装类 ||----|----||boolean|Boolean||byte|Byte||short|Short||int|Integer||long|Long||float|Float||double|Double|#### 为什么要有自动拆装箱功能前面说到，Java 是面向对象语言，操作的大部分是引用数据类型，但是又存在基本数据类型。使用时就有可能涉及到两种类型的转换，比如在 Java SE 5 之前，要想对 Integer 对象赋值的话，需要使用以下方法：```// 1Integer i = new Integer(0); // 从 java 9 开始被废弃		// 2Integer i = Integer.valueOf(0);```要是想获取 Integer 的 int 值的话需要使用以下方法：```Integer iObj=Integer.valueOf(0);int i=iObj.intValue();```所以每次转换都需要 **valueOf()** 或者 **xxxValue()** 方法，显得比较麻烦，自动拆装的出现简化了转换过程。#### 自动拆装箱的实现Java SE 5 后，要是想对一个 Integer 变量赋值的话，可以这样：```Integer iObj=0;```相反，要是想获取 Integer 中的 int 值的话，可以这样：```int i=iOjb```但其实反编译代码后发现，其实还是使用 **valueOf()** 和 **xxxValue()** 实现的，8 种基本数据类型与其包装类都是如此#### 拓展一下有如下测试代码：```// 1Integer integer1 = -1;Integer i1 = -1;System.out.println(integer1 == i1);// 2Integer integer2 = -129;int i2 = -129;System.out.println(integer2 == i2);// 3Integer integer3 = -129;Integer i3 = -129;System.out.println(integer3 == i3);// 4Integer integer4 = 1;Integer i4 = 1;System.out.println(integer4 == i4);// 5Integer integer5 = 128;int i5 = 128;System.out.println(integer5 == i5);// 6Integer integer6 = 128;Integer i6 = 128;System.out.println(integer6 == i6);// 7Integer integer7 = new Integer(1);Integer i7 = new Integer(1);System.out.println(integer7 == i7);// 8Integer integer8 = Integer.valueOf(1);Integer i8 = Integer.valueOf(1);System.out.println(integer8 == i8);```想一想运行结果是啥，下面是正确答案：```true		// 1true		// 2false		// 3true		// 4true		// 5false		// 6false		// 7true		// 8```怎么样，和你想得一样吗？我们来分析一下：  - 在 java 中， **`==`** 用于对象的比较，比较的是对象的内存地址，所以 ***new*** 出来的对象一定是不同的，所以 **7** 是 **false**，但是要注意，这个构造函数在 **java 9** 被废弃了- 前面提到：基本数据类型的包装类有自动拆装箱功能，所以在使用时会先转换成相同的类型，具体是什么类型呢？就 **Integer** 而言，从 Java 5 开始，**Integer** 中引入了一个缓存机制，用于对对象的重用，提高效能。范围是 **[-128, 127]**，在这个区间内值**相等**的  **Integer** 对象都是**相同**的，是同一个对象。`从 **java 6** 开始，这个区间的最大值是可以重新设置的，有兴趣的同学可以看下源码。`分析完后，再去看看那 8 个小测试，应该就能一目了然了。看完这个例子，记住 **Integer** 对象有一个缓存机制哦！